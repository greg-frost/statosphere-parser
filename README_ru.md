# Statosphere Parser

Быстрый и надежный, написанный на Go парсер Телеграм-каналов через веб-страницы "t.me".

## Описание

Парсер может использоваться для получения как основной информации канала, так и списка его сообщений *(постов)*. Это достигается путем парсинга двух типов веб-страниц: `https://t.me/<юзернейм/джойнчат>` и `https://t.me/s/<юзернейм>` соответственно.

> Примечание: Здесь и далее под термином "канал" будут подразумеваться как каналы, публичные и закрытые, так и чаты, боты, пользователи. Однако получение сообщений возможно лишь для публичных каналов.

**Информация канала:**

- Название
- Описание *(если присутствует)*
- Изображение *(аватар)* в виде ссылки
- Тип *(канал, приватный, чат, бот, пользователь)*
- Число подписчиков *(точное или приближенное)*
- Дополнительные счетчики *(фото, видео, файлы и ссылки)*
- Ссылки из описания *(ТГ-ссылки отдельно)*
- Список сообщений *(только для каналов)*
- Метки "верифицирован" и "скам"

Подробную структуру канала можно посмотреть в `channel.Channel`, там же представлены имена полей для вывода в JSON-формате, которые немного отличаются и могут отсутствовать.

**Сообщение канала:**

- ID
- Сообщение *(HTML и текст)*
- Является ли репостом *(если да, то кем и откуда)*
- Был ли текст отредактирован
- Является ли пост опросом *(если да, то сохраняется как текст)*
- Есть ли прикрепленные изображения/видео/документы
- Список вложений *(если были прикреплены)*
- Список хэштегов
- Список кнопок *(URL-кнопки)*
- Список всех ссылок из текста
- Список ТГ-ссылок из текста *(за некоторым исключением)*
- Число просмотров *(точное или приближенное)*
- Дата публикации *(UTC и локальная)*

Подробную структуру сообщения можно посмотреть в `message.Message`, в том числе и разметку JSON-полей.

Также в парсере используются два типа вспомогательных структур для значений и ссылок:

**Value** представляет собой числовую метрику, которая может быть точной или приближенной, например, точное число подписчиков канала: `Exact = 1234`, или приближенное число просмотров сообщений: `Approx = 1200`, `Short = "1.2K"`.

**Links** применяется для отображения списка ссылок и информации по каждой из них, такой как: `Link` - адрес, `Captions` - список описаний *(короткие игнорируются)*, `Posts` - список идентификаторов постов, `Pos` - позиция *(номер по порядку)*, `Count` - количество.

> Примечание: Интерес представляют не все ТГ-ссылки, но лишь то, что можно назвать "рекламным" или "коммерческим" упоминанием, поэтому часть ссылок игнорируется, а именно:

- Ссылки на сам канал, т.к. авторы часто подписывают свои посты подобным образом,
- Ссылки на связанные каналы *(`Siblings`)*, т.е. ТГ-ссылки, указанные в описании канала,
- Часто повторяющиеся ссылки: например, если из 10 постов ссылка встречается хотя бы в 3-х, она добавляется в список `Siblings` и более не учитывается.

Эти меры призваны сделать `Advs` готовым решением для отслеживания упоминаний, тем более что все ссылки присутствуют в массиве `Links` *(туда же, кстати, дублируются и URL-кнопки `Buttons`)*.

## Использование

Парсер может работать в нескольких режимах:

### Сервер

Это основной режим, поэтому для запуска сервера достаточно просто вызвать скомпилированный файл без аргументов или задать необязательные флаги:

- `-mode server` или просто `-server` для принудительного запуска в виде сервера,
- `-proxy=<true или false>` для включения/выключения прокси *(по умолчанию включен)*,
- `-address <адрес сервера>` и `-port <число>` для выбора значений адреса и порта, отличных от *localhost* и *8080* соответственно.

Например, если скомпилированный файл называется "parser", то запуск в режиме сервера может выглядеть так:

```
./parser
```
или
```
./parser -server -address "https://example.com" -port 80 -proxy=false
```

После запуска сервера можно обращаться к страницам `/`, `/info` и `/messages` без аргументов *(тогда будут показаны веб-формы для выбора режима работы и управляемого парсинга информации и сообщений)* или сразу делать GET-запросы, используя следующие параметры:

- `channel=<юзернейм/джойнчат>` или `channels=<список через пробел/запятую или массив>` для указания каналов или вместо этого можно задать флаг `test=true` для работы с тестовыми данными,
- `limit=<число>` и `offset=<число>` для ограничения и смещения выборки,
- `messages=<число>` для парсинга сообщений и `exact=true` для получения точного числа подписчиков *(только для `/messages`)*.

> Примечание: Тестовые каналы - это список из 150 популярных каналов по IT-тематике, которые находятся в файле `data/channels` и которые хорошо подходят для тестирования работы парсера.

Результат обработки GET-запроса будет выдан в JSON-формате. Для страницы `/info` это будет список каналов с общей информацией, для `/messages` - общая информация *(число подписчиков может быть неточным)* + список последних сообщений для каждого канала. Для получения и сообщений и точного числа подписчиков необходимо использовать флаг `exact=true`, но это будет стоить дополнительного запроса к странице `https://t.me/<юзернейм>`.

Например, если сервер запущен по адресу `http://localhost:8080`, то получение общей информации о канале "telegram" может выглядеть так:

```
http://localhost:8080/info?channel=telegram
```

А получение первых 50 из 150 тестовых каналов с общей информацией *(и точным числом подписчиков)* по 10 сообщений в каждом может выглядеть так:

```
http://localhost:8080/messages?test=true&limit=50&messages=10&exact=true
```

**О прокси**

Прокси необходимы для обхода ограничений сайта Телеграм, который позволяет делать, ориентировочно, 300 запросов в минуту с одного IP-адреса *(при превышении предела, Телеграм выдает страницу в таком виде, как будто канала не существует)*.

Использование прокси по умолчанию включено и, когда это возможно, он не применяется, уступая место обычным запросам. Сами адреса прокси-серверов находятся в файле `data/proxies`, но они общедоступные и работают соответственно, поэтому для активного парсинга необходимо ввести новые адреса приватных прокси-серверов в таком же формате, какой используется в файле.

Возможно, придется изменить настройки в `proxy.Enable(...)` - там задаются пределы для запросов без прокси, с прокси и время, за которое "остывает" не-прокси, т.е. ограничение сайта Телеграм, чтобы можно было вернуться к обычной работе. Также для тестирования прокси существует отдельный режим, который включается флагом `-mode proxy`, а параметры тестирования задаются в `channels.TestProxy(...)`.

### Консоль

Данный режим парсера включается с помощью флагов `-mode console` или просто `-console`. Далее можно будет ввести следующие флаги:

- `-channel <юзернейм/джойнчат>` или `-channels <список через пробел/запятую>` для указания каналов или флаг `-test` для использования тестовых данных,
- `-limit <число>` и `-offset <число>` для ограничения и смещения выборки,
- `-messages <число>` для парсинга сообщений и `-exact` для получения точного числа подписчиков.

В результате каналы и сообщения будут спарсены и выведены на экран.

Например, если скомпилированный файл называется "parser", то получение первых 50 из 150 тестовых каналов с общей информацией по 10 сообщений в каждом в консольном режиме может выглядеть так:

```
./parser -console -test -messages 10 -limit 50
```

### Пакет

В случае использования парсера в качестве пакета, необходимо импортировать модуль *(пакет `parse`)* и написать примерно такой код:

```
// Инициализация
channels := parse.NewChannels()

// Заполнение

channels.Add("username") // по одному,
channels.PrepareFromString("username1, username2 username3") // из строки
channels.PrepareFromFile("data/channels") // или из файла

// Ограничение выборки
channels.Limit(0, 50)

// Парсинг

messages := 10 // необходимое число сообщений
isExact := true // получение точного количества подписчиков
_, errs := channels.Parse(context.Background(), isExact, messages)

// Использование результатов

if channel, ok := channels.Find("username"); ok { // поиск необходимых
	fmt.Println(channel.Title);
	fmt.Println(channel.About);
	fmt.Println(channel.Kind);
	// ...

	// (полный список доступных полей 
	// находится в channel.Channel)
}
for _, channel := range channels.Channels.Channels { // или обход всех
	// ...
}

// Также можно просто распечатать результаты в консоль
channels.Print(true) // false - только информация, true - с сообщениями

// Или вывести в JSON
// (нужно будет импортировать пакет "response")

channels.RemoveUnparsed() // удаление каналов без информации
channels.RemoveUnmessaged() // удаление каналов без сообщений

json := response.New(
	channels.Channels.Channels, channels.Count(),
	errs, time.Now().Sub(start),
)
result, _ := json.EncodeJSON()
response.PrintJSON(res, result)
```

## P.S.

Я перешел на язык Go совсем недавно, и написал этот парсер скорее для того, чтобы потренироваться и создать репрезентативный демо-проект, в котором бы использовалось все то, чему я научился, однако если этот код кому-нибудь поможет, я буду рад. И вообще было интересно слегка поучаствовать в Open Source. Кстати, существует также и [английская версия](README.md) данной инструкции. Удачи!